#!/usr/bin/env python3
import argparse
import subprocess
import sys
from typing import List, Tuple, Dict, Optional


def run(
    cmd: List[str], capture: bool = True, check: bool = True, text: bool = True
) -> subprocess.CompletedProcess:
    return subprocess.run(cmd, capture_output=capture, check=check, text=text)


def jj_changes_in_range(base: str, target_change: str) -> List[str]:
    """
    Return a list of short change IDs in BASE..TARGET, ordered oldest->newest.
    """
    # Get list (newest first), then reverse.
    # Using short change ids for branch names as requested by user flow.
    cp = run(
        [
            "jj",
            "log",
            "-r",
            f"{base}..{target_change}",
            "-T",
            'change_id.short() ++ "\n"',
            "--no-graph",
        ]
    )
    ids = [line.strip() for line in cp.stdout.splitlines() if line.strip()]
    ids.reverse()
    return ids


def jj_description(change: str) -> Tuple[str, str]:
    """
    Return (title, body) from the change description.
    Title = first line; body = remaining lines (may be empty).
    """
    cp = run(["jj", "log", "-r", change, "-T", "description", "--no-graph"])
    full = cp.stdout.replace("\r\n", "\n").replace("\r", "\n").strip()
    if not full:
        return f"Change {change}", ""

    lines = full.splitlines()
    title = lines[0].strip() if lines else f"Change {change}"
    body = "\n".join(lines[1:]).strip() if len(lines) > 1 else ""
    return title, body


def gh_pr_create(
    head_branch: str,
    base_branch: str,
    title: str,
    body: str,
    reviewers: Optional[str] = None,
    upstream_repo: Optional[str] = None,
    fork_user: Optional[str] = None,
) -> int:
    """
    Create PR and return its number.
    If upstream_repo and fork_user are provided, creates PR using -R upstream_repo and -H fork_user:head_branch.
    """
    # Ensure body is not None
    body_text = body or ""

    # Build the command
    cmd = ["gh"]

    # Add upstream repo if specified
    if upstream_repo:
        cmd.extend(["-R", upstream_repo])

    cmd.extend(["pr", "create"])

    # Determine head branch format
    if fork_user and upstream_repo:
        head_branch_spec = f"{fork_user}:{head_branch}"
    else:
        head_branch_spec = head_branch

    cmd.extend(
        [
            "-H",
            head_branch_spec,
            "-B",
            base_branch,
            "-t",
            title,
            "-b",
            body_text,
        ]
    )

    # Add reviewers if specified
    if reviewers:
        cmd.extend(["--reviewer", reviewers])

    # Create the PR first
    run(cmd)

    # Then get the PR number using gh pr view with JSON output
    view_cmd = ["gh"]
    if upstream_repo:
        view_cmd.extend(["-R", upstream_repo])
    view_cmd.extend(
        ["pr", "view", head_branch_spec, "--json", "number", "--jq", ".number"]
    )
    cp = run(view_cmd)
    pr_number_str = cp.stdout.strip()
    try:
        return int(pr_number_str)
    except ValueError:
        print(
            f"Failed to parse PR number from gh output: {pr_number_str}",
            file=sys.stderr,
        )
        raise


def gh_pr_get_body(pr_number: int, upstream_repo: Optional[str] = None) -> str:
    """Get the body of an existing PR."""
    cmd = ["gh"]
    if upstream_repo:
        cmd.extend(["-R", upstream_repo])
    cmd.extend(["pr", "view", str(pr_number), "--json", "body", "--jq", ".body"])
    cp = run(cmd)
    return cp.stdout.strip()  # Strip whitespace for cleaner handling


def gh_pr_exists(
    branch: str, upstream_repo: Optional[str] = None, fork_user: Optional[str] = None
) -> bool:
    """Check if a PR already exists for the given branch."""
    try:
        cmd = ["gh"]

        # Add upstream repo if specified
        if upstream_repo:
            cmd.extend(["-R", upstream_repo])

        cmd.extend(["pr", "view"])

        # Use fork_user:branch format if we're in fork workflow
        if fork_user and upstream_repo:
            branch_spec = f"{fork_user}:{branch}"
        else:
            branch_spec = branch

        cmd.extend([branch_spec, "--json", "number"])

        run(cmd, capture=True)
        return True
    except subprocess.CalledProcessError:
        return False


def gh_pr_set_body(
    pr_number: int, new_body: str, upstream_repo: Optional[str] = None
) -> None:
    # Pass body as a single arg; subprocess handles quoting safely.
    cmd = ["gh"]
    if upstream_repo:
        cmd.extend(["-R", upstream_repo])
    cmd.extend(["pr", "edit", str(pr_number), "--body", new_body])
    run(cmd)


def gh_pr_set_title(
    pr_number: int, new_title: str, upstream_repo: Optional[str] = None
) -> None:
    cmd = ["gh"]
    if upstream_repo:
        cmd.extend(["-R", upstream_repo])
    cmd.extend(["pr", "edit", str(pr_number), "--title", new_title])
    run(cmd)


def gh_pr_add_reviewers(
    pr_number: int, reviewers: str, upstream_repo: Optional[str] = None
) -> None:
    """Add reviewers to an existing PR."""
    cmd = ["gh"]
    if upstream_repo:
        cmd.extend(["-R", upstream_repo])
    cmd.extend(["pr", "edit", str(pr_number), "--add-reviewer", reviewers])
    run(cmd)


def gh_pr_get_title(pr_number: int, upstream_repo: Optional[str] = None) -> str:
    """Get the title of an existing PR."""
    cmd = ["gh"]
    if upstream_repo:
        cmd.extend(["-R", upstream_repo])
    cmd.extend(["pr", "view", str(pr_number), "--json", "title", "--jq", ".title"])
    cp = run(cmd)
    return cp.stdout.strip()


def get_repo_info() -> Tuple[str, str]:
    """Get repo owner and name from gh cli."""
    cp = run(
        [
            "gh",
            "repo",
            "view",
            "--json",
            "owner,name",
            "--jq",
            '.owner.login + "/" + .name',
        ]
    )
    return cp.stdout.strip(), cp.stdout.strip().split("/")[-1]


def get_commit_hash(change_id: str) -> str:
    """Get full commit hash for a change ID."""
    cp = run(["jj", "log", "-r", change_id, "-T", "commit_id", "--no-graph"])
    return cp.stdout.strip()


def get_fork_username() -> str:
    """
    Get the fork username from the git 'origin' remote.
    Extracts username from GitHub URLs like:
    - https://github.com/username/repo.git -> username
    - git@github.com:username/repo.git -> username
    """
    try:
        cp = run(["git", "remote", "get-url", "origin"])
        origin_url = cp.stdout.strip()

        # Handle HTTPS URLs: https://github.com/username/repo.git
        if "github.com" in origin_url:
            if origin_url.startswith("https://github.com/"):
                path = origin_url[len("https://github.com/") :]
                username = path.split("/")[0]
            elif origin_url.startswith("git@github.com:"):
                path = origin_url[len("git@github.com:") :]
                username = path.split("/")[0]
            else:
                raise ValueError(f"Unrecognized GitHub URL format: {origin_url}")

            # Basic validation
            if not username or not username.replace("-", "").isalnum():
                raise ValueError(
                    f"Invalid username extracted from origin URL: '{username}'"
                )

            return username
        else:
            raise ValueError(f"Origin remote is not a GitHub URL: {origin_url}")

    except subprocess.CalledProcessError as e:
        raise ValueError(f"Failed to get git origin remote: {e.stderr or str(e)}")


def build_stack_block(all_prs: List[int], current: int) -> str:
    """
    Build the 'Stacked PRs' block with an arrow on the current PR.
    Newest PRs at top, oldest at bottom.
    """
    lines = ["PRs:"]
    # Reverse the list so newest (last in the list) appears first
    for n in reversed(all_prs):
        if n == current:
            lines.append(f"* ➡️ #{n}")
        else:
            lines.append(f"* #{n}")
    return "\n".join(lines)


def build_stacked_pr_body(
    change_id: str, pr_number: int, all_prs: List[int], commit_body: str, repo_name: str
) -> str:
    """Build the body for a stacked PR."""
    commit_hash = get_commit_hash(change_id)
    short_hash = commit_hash[:7]

    # Build the main content
    lines = []
    lines.append(
        f"This is a stacked PR[^1]. Only review commit [{short_hash}](https://github.com/{repo_name}/pull/{pr_number}/commits/{commit_hash})."
    )
    lines.append("")
    lines.append(build_stack_block(all_prs, pr_number))
    lines.append("")
    if commit_body:
        lines.append("---")
        lines.append("")
        lines.append(commit_body)
        lines.append("")
    lines.append(
        "[^1]: A stacked PR is a pull request that depends on other pull requests. The current PR depends on the ones listed below it and MUST NOT be merged before they are merged. The PRs listed above the current one in turn depend on it and won't be merged until the current one is."
    )
    lines.append("")

    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(
        description="Create GitHub PRs for all jj changes in BASE..CHANGE_ID as a stacked series."
    )
    parser.add_argument(
        "change_id", help="Top change ID to build PRs for (e.g., rktqquxy)."
    )
    parser.add_argument(
        "-B", "--base", default="main", help="Base branch to target (default: main)."
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would happen without pushing/creating PRs.",
    )
    parser.add_argument(
        "--add-reviewer",
        help="Comma-separated list of reviewers to add to the PR (same format as gh pr create/edit).",
    )
    parser.add_argument(
        "-R",
        "--repo",
        dest="upstream_repo",
        help="Upstream repository URL (e.g., 'https://github.com/jackblack/runner'). PRs will be created in this repository with head from fork.",
    )
    args = parser.parse_args()

    # Validate we're in a jj repository
    try:
        run(["jj", "status"], capture=True)
    except subprocess.CalledProcessError:
        print("Error: Not in a jj repository or jj not available.", file=sys.stderr)
        sys.exit(1)

    try:
        changes = jj_changes_in_range(args.base, args.change_id)
    except subprocess.CalledProcessError as e:
        error_msg = e.stderr or str(e)
        if "No such revision" in error_msg:
            print(
                f"Error: Change ID '{args.change_id}' not found. Make sure it's a valid change ID.",
                file=sys.stderr,
            )
        else:
            print(f"Error getting changes: {error_msg}", file=sys.stderr)
        sys.exit(1)

    if not changes:
        print(
            f"No changes found in range {args.base}..{args.change_id}. Nothing to do."
        )
        return

    print(f"Discovered {len(changes)} change(s) in stack: {' '.join(changes)}")

    # Handle fork-to-upstream workflow if -R is specified
    fork_username = None
    upstream_repo_url = None
    if args.upstream_repo:
        upstream_repo_url = args.upstream_repo
        try:
            fork_username = get_fork_username()
            print(f"Fork detected: will push branches to {fork_username}'s fork")
            print(f"PRs will be created in upstream repository: {upstream_repo_url}")
        except ValueError as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)

    # Get repo info for commit links
    repo_name, _ = get_repo_info()

    branches: Dict[str, str] = {}  # change_id -> branch name
    pr_numbers: Dict[str, int] = {}  # change_id -> PR number

    for change in changes:
        branch = f"push-{change}"
        title, body = ("", "")
        try:
            title, body = jj_description(change)
        except subprocess.CalledProcessError as e:
            print(
                f"[{change}] Failed to read description: {e.stderr or str(e)}",
                file=sys.stderr,
            )
            sys.exit(1)

        print(f"[{change}] Will use branch '{branch}' and title '{title}'")

        if args.dry_run:
            print(f"[{change}] DRY-RUN: jj git push --allow-new -b {branch}")
            print(
                f"[{change}] DRY-RUN: gh pr create -H {branch} -B {args.base} -t '{title}' -b <body>"
            )
            branches[change] = branch
            pr_numbers[change] = -1  # placeholder
            continue

        # Create bookmark/branch and push
        try:
            # Create bookmark if it doesn't exist
            try:
                run(["jj", "bookmark", "create", branch, "-r", change], capture=True)
                print(f"[{change}] Created bookmark '{branch}'")
            except subprocess.CalledProcessError:
                # Bookmark might already exist, that's ok
                print(f"[{change}] Bookmark '{branch}' already exists")

            # Push the bookmark
            run(["jj", "git", "push", "--allow-new", "-b", branch])
            branches[change] = branch
            print(f"[{change}] Pushed bookmark '{branch}'")
        except subprocess.CalledProcessError as e:
            print(f"[{change}] Push failed: {e.stderr or str(e)}", file=sys.stderr)
            sys.exit(1)

        # Create or update PR
        try:
            if gh_pr_exists(branch, upstream_repo_url, fork_username):
                print(
                    f"[{change}] PR already exists for branch '{branch}', getting PR number..."
                )
                cmd = ["gh"]
                if upstream_repo_url:
                    cmd.extend(["-R", upstream_repo_url])
                cmd.extend(["pr", "view"])

                # Use fork_user:branch format if we're in fork workflow
                if fork_username and upstream_repo_url:
                    branch_spec = f"{fork_username}:{branch}"
                else:
                    branch_spec = branch

                cmd.extend([branch_spec, "--json", "number", "--jq", ".number"])
                cp = run(cmd)
                pr_num = int(cp.stdout.strip())
                print(f"[{change}] Found existing PR #{pr_num}")

                # Check if title needs updating
                existing_title = gh_pr_get_title(pr_num, upstream_repo_url)
                if existing_title != title:
                    gh_pr_set_title(pr_num, title, upstream_repo_url)
                    print(f"[{change}] Updated PR #{pr_num} title")

                # Add reviewers if specified
                if args.add_reviewer:
                    gh_pr_add_reviewers(pr_num, args.add_reviewer, upstream_repo_url)
                    print(f"[{change}] Added reviewers to PR #{pr_num}")

                pr_numbers[change] = pr_num
            else:
                # For single change, use commit body directly; for multiple changes we'll update later
                initial_body = body if len(changes) == 1 else ""
                pr_num = gh_pr_create(
                    branch,
                    args.base,
                    title,
                    initial_body,
                    args.add_reviewer,
                    upstream_repo_url,
                    fork_username,
                )
                print(f"[{change}] Created PR #{pr_num}")
                pr_numbers[change] = pr_num
        except subprocess.CalledProcessError as e:
            print(
                f"[{change}] PR creation/lookup failed: {e.stderr or str(e)}",
                file=sys.stderr,
            )
            sys.exit(1)

    # Update PR bodies based on whether it's single or stacked
    created_prs_in_order = [pr_numbers[c] for c in changes if pr_numbers.get(c, -1) > 0]

    if not args.dry_run:
        print("Updating PR descriptions…")

        # Get commit bodies for each change
        change_bodies = {}
        for change in changes:
            _, body = jj_description(change)
            change_bodies[change] = body

        for change in changes:
            pr_num = pr_numbers.get(change, -1)
            if pr_num <= 0:
                continue

            try:
                if len(created_prs_in_order) == 1:
                    # Single PR: use commit body directly
                    new_body = change_bodies[change] or ""
                else:
                    # Stacked PR: use special format
                    new_body = build_stacked_pr_body(
                        change,
                        pr_num,
                        created_prs_in_order,
                        change_bodies[change],
                        repo_name,
                    )

                # Check if body needs updating
                existing_body = gh_pr_get_body(pr_num, upstream_repo_url)
                if existing_body != new_body:
                    gh_pr_set_body(pr_num, new_body, upstream_repo_url)
                    print(f"[{change}] Updated PR #{pr_num} body")
                else:
                    print(f"[{change}] PR #{pr_num} body already up to date")

            except subprocess.CalledProcessError as e:
                print(
                    f"[{change}] Failed to update PR #{pr_num} body: {e.stderr or str(e)}",
                    file=sys.stderr,
                )
                sys.exit(1)

    # Summary
    print("\n=== Summary ===")
    for change in changes:
        branch = branches.get(change, "?")
        prn = pr_numbers.get(change, -1)
        if prn > 0:
            print(f"{change} -> branch '{branch}' -> PR #{prn}")
        else:
            print(f"{change} -> branch '{branch}' -> (no PR created in dry-run)")


if __name__ == "__main__":
    main()
