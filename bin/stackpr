#!/usr/bin/env python3
import argparse
import difflib
import subprocess
import sys
from typing import List, Tuple, Dict, Optional


def run(
    cmd: List[str], capture: bool = True, check: bool = True, text: bool = True
) -> subprocess.CompletedProcess:
    return subprocess.run(cmd, capture_output=capture, check=check, text=text)


def jj_changes_in_range(base: str, target_change: str) -> List[str]:
    """
    Return a list of short change IDs in BASE..TARGET, ordered oldest->newest.
    """
    # Get list (newest first), then reverse.
    # Using short change ids for branch names as requested by user flow.
    cp = run(
        [
            "jj",
            "log",
            "-r",
            f"{base}..{target_change}",
            "-T",
            'change_id.short() ++ "\n"',
            "--no-graph",
        ]
    )
    ids = [line.strip() for line in cp.stdout.splitlines() if line.strip()]
    ids.reverse()
    return ids


def jj_description(change: str) -> Tuple[str, str]:
    """
    Return (title, body) from the change description.
    Title = first line; body = remaining lines (may be empty).
    """
    cp = run(["jj", "log", "-r", change, "-T", "description", "--no-graph"])
    full = cp.stdout.replace("\r\n", "\n").replace("\r", "\n").strip()
    if not full:
        return f"Change {change}", ""

    lines = full.splitlines()
    title = lines[0].strip() if lines else f"Change {change}"
    body = "\n".join(lines[1:]).strip() if len(lines) > 1 else ""
    return title, body


def gh_pr_create(
    head_branch: str,
    base_branch: str,
    title: str,
    body: str,
    reviewers: Optional[str] = None,
    upstream_repo: Optional[str] = None,
    fork_user: Optional[str] = None,
) -> int:
    """
    Create PR and return its number.
    If upstream_repo and fork_user are provided, creates PR using -R upstream_repo and -H fork_user:head_branch.
    """
    # Ensure body is not None
    body_text = body or ""

    # Build the command
    cmd = ["gh"]

    # Add upstream repo if specified
    if upstream_repo:
        cmd.extend(["-R", upstream_repo])

    cmd.extend(["pr", "create"])

    # Determine head branch format
    if fork_user and upstream_repo:
        head_branch_spec = f"{fork_user}:{head_branch}"
    else:
        head_branch_spec = head_branch

    cmd.extend(
        [
            "-H",
            head_branch_spec,
            "-B",
            base_branch,
            "-t",
            title,
            "-b",
            body_text,
        ]
    )

    # Add reviewers if specified
    if reviewers:
        cmd.extend(["--reviewer", reviewers])

    # Create the PR first
    run(cmd)

    # Then get the PR number using gh pr view with JSON output
    view_cmd = ["gh"]
    if upstream_repo:
        view_cmd.extend(["-R", upstream_repo])
    view_cmd.extend(
        ["pr", "view", head_branch_spec, "--json", "number", "--jq", ".number"]
    )
    cp = run(view_cmd)
    pr_number_str = cp.stdout.strip()
    try:
        return int(pr_number_str)
    except ValueError:
        print(
            f"Failed to parse PR number from gh output: {pr_number_str}",
            file=sys.stderr,
        )
        raise


def gh_pr_get_body(pr_number: int, upstream_repo: Optional[str] = None) -> str:
    """Get the body of an existing PR."""
    cmd = ["gh"]
    if upstream_repo:
        cmd.extend(["-R", upstream_repo])
    cmd.extend(["pr", "view", str(pr_number), "--json", "body", "--jq", ".body"])
    cp = run(cmd)
    return cp.stdout.strip()  # Strip whitespace for cleaner handling


def gh_pr_exists(
    branch: str, upstream_repo: Optional[str] = None, fork_user: Optional[str] = None
) -> bool:
    """Check if a PR already exists for the given branch."""
    try:
        cmd = ["gh"]

        # Add upstream repo if specified
        if upstream_repo:
            cmd.extend(["-R", upstream_repo])

        cmd.extend(["pr", "view"])

        # Use fork_user:branch format if we're in fork workflow
        if fork_user and upstream_repo:
            branch_spec = f"{fork_user}:{branch}"
        else:
            branch_spec = branch

        cmd.extend([branch_spec, "--json", "number"])

        run(cmd, capture=True)
        return True
    except subprocess.CalledProcessError:
        return False


def gh_pr_set_body(
    pr_number: int, new_body: str, upstream_repo: Optional[str] = None
) -> None:
    # Pass body as a single arg; subprocess handles quoting safely.
    cmd = ["gh"]
    if upstream_repo:
        cmd.extend(["-R", upstream_repo])
    cmd.extend(["pr", "edit", str(pr_number), "--body", new_body])
    run(cmd)


def gh_pr_set_title(
    pr_number: int, new_title: str, upstream_repo: Optional[str] = None
) -> None:
    cmd = ["gh"]
    if upstream_repo:
        cmd.extend(["-R", upstream_repo])
    cmd.extend(["pr", "edit", str(pr_number), "--title", new_title])
    run(cmd)


def gh_pr_add_reviewers(
    pr_number: int, reviewers: str, upstream_repo: Optional[str] = None
) -> None:
    """Add reviewers to an existing PR."""
    cmd = ["gh"]
    if upstream_repo:
        cmd.extend(["-R", upstream_repo])
    cmd.extend(["pr", "edit", str(pr_number), "--add-reviewer", reviewers])
    run(cmd)


def gh_pr_get_title(pr_number: int, upstream_repo: Optional[str] = None) -> str:
    """Get the title of an existing PR."""
    cmd = ["gh"]
    if upstream_repo:
        cmd.extend(["-R", upstream_repo])
    cmd.extend(["pr", "view", str(pr_number), "--json", "title", "--jq", ".title"])
    cp = run(cmd)
    return cp.stdout.strip()


def get_repo_info() -> Tuple[str, str]:
    """Get repo owner and name from gh cli."""
    cp = run(
        [
            "gh",
            "repo",
            "view",
            "--json",
            "owner,name",
            "--jq",
            '.owner.login + "/" + .name',
        ]
    )
    return cp.stdout.strip(), cp.stdout.strip().split("/")[-1]


def get_commit_hash(change_id: str) -> str:
    """Get full commit hash for a change ID."""
    cp = run(["jj", "log", "-r", change_id, "-T", "commit_id", "--no-graph"])
    return cp.stdout.strip()


def get_fork_username() -> str:
    """
    Get the fork username from the git 'origin' remote.
    Extracts username from GitHub URLs like:
    - https://github.com/username/repo.git -> username
    - git@github.com:username/repo.git -> username
    """
    try:
        cp = run(["git", "remote", "get-url", "origin"])
        origin_url = cp.stdout.strip()

        # Handle HTTPS URLs: https://github.com/username/repo.git
        if "github.com" in origin_url:
            if origin_url.startswith("https://github.com/"):
                path = origin_url[len("https://github.com/") :]
                username = path.split("/")[0]
            elif origin_url.startswith("git@github.com:"):
                path = origin_url[len("git@github.com:") :]
                username = path.split("/")[0]
            else:
                raise ValueError(f"Unrecognized GitHub URL format: {origin_url}")

            # Basic validation
            if not username or not username.replace("-", "").isalnum():
                raise ValueError(
                    f"Invalid username extracted from origin URL: '{username}'"
                )

            return username
        else:
            raise ValueError(f"Origin remote is not a GitHub URL: {origin_url}")

    except subprocess.CalledProcessError as e:
        raise ValueError(f"Failed to get git origin remote: {e.stderr or str(e)}")


def build_stack_block(all_prs: List[int], current: int) -> str:
    """
    Build the 'Stacked PRs' block with an arrow on the current PR.
    Newest PRs at top, oldest at bottom.
    """
    lines = ["PRs:"]
    # Reverse the list so newest (last in the list) appears first
    for n in reversed(all_prs):
        if n == current:
            lines.append(f"* ➡️ #{n}")
        else:
            lines.append(f"* #{n}")
    return "\n".join(lines)


COLLAPSE_THRESHOLD = 20
MAX_COMMENT_CHARS = 60000


def parse_git_diff(diff_text: str) -> List[Tuple[str, str]]:
    """Parse a git diff into per-file chunks. Returns list of (filename, diff_chunk)."""
    files = []
    current_file = None
    current_lines: List[str] = []

    for line in diff_text.splitlines(keepends=True):
        if line.startswith("diff --git "):
            if current_file is not None:
                files.append((current_file, "".join(current_lines)))
            parts = line.split(" b/", 1)
            current_file = parts[1].rstrip("\n") if len(parts) == 2 else "unknown"
            current_lines = [line]
        elif current_file is not None:
            current_lines.append(line)

    if current_file is not None:
        files.append((current_file, "".join(current_lines)))

    return files


def diff_stats(chunk: str) -> Tuple[int, int]:
    """Count added and removed lines in a diff chunk."""
    added = removed = 0
    for line in chunk.splitlines():
        if line.startswith("+") and not line.startswith("+++"):
            added += 1
        elif line.startswith("-") and not line.startswith("---"):
            removed += 1
    return added, removed


def get_remote_bookmark_commit(branch: str) -> Optional[str]:
    """Get the commit hash of the remote bookmark, or None if it doesn't exist."""
    try:
        cp = run(
            ["jj", "log", "-r", f"{branch}@origin", "-T", "commit_id", "--no-graph"],
            capture=True,
        )
        return cp.stdout.strip() or None
    except subprocess.CalledProcessError:
        return None


def get_remote_bookmark_description(branch: str) -> str:
    """Get the description of the remote bookmark."""
    cp = run(
        ["jj", "log", "-r", f"{branch}@origin", "-T", "description", "--no-graph"],
        capture=True,
    )
    return cp.stdout.strip()


def get_code_diff(old_commit: str, new_change: str) -> str:
    """Get code diff between old git commit and new jj change."""
    cp = run(
        ["jj", "interdiff", "--git", "--from", old_commit, "--to", new_change],
        capture=True,
    )
    return cp.stdout


def create_text_diff(
    old_text: str, new_text: str, from_label: str = "old", to_label: str = "new"
) -> str:
    """Create a unified diff between two text strings."""
    old_lines = old_text.splitlines(keepends=True)
    new_lines = new_text.splitlines(keepends=True)
    # Ensure lines end with newline for proper diff formatting
    if old_lines and not old_lines[-1].endswith("\n"):
        old_lines[-1] += "\n"
    if new_lines and not new_lines[-1].endswith("\n"):
        new_lines[-1] += "\n"
    diff = difflib.unified_diff(
        old_lines, new_lines, fromfile=from_label, tofile=to_label
    )
    return "".join(diff)


def gh_pr_comment(
    pr_number: int, body: str, upstream_repo: Optional[str] = None
) -> None:
    """Post a comment to a PR."""
    cmd = ["gh"]
    if upstream_repo:
        cmd.extend(["-R", upstream_repo])
    cmd.extend(["pr", "comment", str(pr_number), "--body", body])
    run(cmd)


def build_diff_comment(code_diff: str, message_diff: str) -> str:
    """Build a PR comment with per-file collapsible code diffs."""
    files = parse_git_diff(code_diff) if code_diff.strip() else []
    has_message_changes = bool(message_diff.strip())

    if not files and not has_message_changes:
        return "### Changes since last push\n\nNo content changes since last push."

    sections = ["### Changes since last push"]

    total_code_lines = sum(len(chunk.splitlines()) for _, chunk in files)
    expand = total_code_lines <= COLLAPSE_THRESHOLD

    for filename, chunk in files:
        added, removed = diff_stats(chunk)
        open_attr = " open" if expand else ""
        sections.append(
            f"\n<details{open_attr}>\n<summary><code>{filename}</code> (+{added}, -{removed})</summary>\n"
            f"\n```diff\n{chunk.rstrip()}\n```\n"
            f"\n</details>"
        )

    if has_message_changes:
        message_lines = message_diff.splitlines()
        open_attr = " open" if len(message_lines) <= COLLAPSE_THRESHOLD else ""
        sections.append(
            f"\n<details{open_attr}>\n<summary>Commit message changes</summary>\n"
            f"\n```diff\n{message_diff.rstrip()}\n```\n"
            f"\n</details>"
        )

    comment = "\n".join(sections)
    if len(comment) > MAX_COMMENT_CHARS:
        return (
            "### Changes since last push\n\n"
            f"Diff too large to display ({len(comment)} characters, {len(files)} files)."
        )
    return comment


def build_stacked_pr_body(
    change_id: str, pr_number: int, all_prs: List[int], commit_body: str, repo_name: str
) -> str:
    """Build the body for a stacked PR."""
    commit_hash = get_commit_hash(change_id)
    short_hash = commit_hash[:7]

    # Build the main content
    lines = []
    lines.append(
        f"This is a stacked PR[^1]. Only review commit [{short_hash}](https://github.com/{repo_name}/pull/{pr_number}/commits/{commit_hash})."
    )
    lines.append("")
    lines.append(build_stack_block(all_prs, pr_number))
    lines.append("")
    if commit_body:
        lines.append("---")
        lines.append("")
        lines.append(commit_body)
        lines.append("")
    lines.append(
        "[^1]: A stacked PR is a pull request that depends on other pull requests. The current PR depends on the ones listed below it and MUST NOT be merged before they are merged. The PRs listed above the current one in turn depend on it and won't be merged until the current one is."
    )
    lines.append("")

    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(
        description="Create GitHub PRs for all jj changes in BASE..CHANGE_ID as a stacked series."
    )
    parser.add_argument(
        "change_id", help="Top change ID to build PRs for (e.g., rktqquxy)."
    )
    parser.add_argument(
        "-B", "--base", default="main", help="Base branch to target (default: main)."
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would happen without pushing/creating PRs.",
    )
    parser.add_argument(
        "--add-reviewer",
        help="Comma-separated list of reviewers to add to the PR (same format as gh pr create/edit).",
    )
    parser.add_argument(
        "-R",
        "--repo",
        dest="upstream_repo",
        help="Upstream repository URL (e.g., 'https://github.com/jackblack/runner'). PRs will be created in this repository with head from fork.",
    )
    args = parser.parse_args()

    # Validate we're in a jj repository
    try:
        run(["jj", "status"], capture=True)
    except subprocess.CalledProcessError:
        print("Error: Not in a jj repository or jj not available.", file=sys.stderr)
        sys.exit(1)

    try:
        changes = jj_changes_in_range(args.base, args.change_id)
    except subprocess.CalledProcessError as e:
        error_msg = e.stderr or str(e)
        if "No such revision" in error_msg:
            print(
                f"Error: Change ID '{args.change_id}' not found. Make sure it's a valid change ID.",
                file=sys.stderr,
            )
        else:
            print(f"Error getting changes: {error_msg}", file=sys.stderr)
        sys.exit(1)

    if not changes:
        print(
            f"No changes found in range {args.base}..{args.change_id}. Nothing to do."
        )
        return

    print(f"Discovered {len(changes)} change(s) in stack: {' '.join(changes)}")

    # Handle fork-to-upstream workflow if -R is specified
    fork_username = None
    upstream_repo_url = None
    if args.upstream_repo:
        upstream_repo_url = args.upstream_repo
        try:
            fork_username = get_fork_username()
            print(f"Fork detected: will push branches to {fork_username}'s fork")
            print(f"PRs will be created in upstream repository: {upstream_repo_url}")
        except ValueError as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)

    # Get repo info for commit links
    repo_name, _ = get_repo_info()

    branches: Dict[str, str] = {}  # change_id -> branch name
    pr_numbers: Dict[str, int] = {}  # change_id -> PR number

    for change in changes:
        branch = f"push-{change}"
        title, body = ("", "")
        try:
            title, body = jj_description(change)
        except subprocess.CalledProcessError as e:
            print(
                f"[{change}] Failed to read description: {e.stderr or str(e)}",
                file=sys.stderr,
            )
            sys.exit(1)

        print(f"[{change}] Will use branch '{branch}' and title '{title}'")

        if args.dry_run:
            print(f"[{change}] DRY-RUN: jj git push --allow-new -b {branch}")
            print(
                f"[{change}] DRY-RUN: gh pr create -H {branch} -B {args.base} -t '{title}' -b <body>"
            )
            branches[change] = branch
            pr_numbers[change] = -1  # placeholder
            continue

        # Check if remote bookmark exists (to calculate diff for existing PRs)
        old_remote_commit = get_remote_bookmark_commit(branch)
        old_commit_message = None
        if old_remote_commit:
            old_commit_message = get_remote_bookmark_description(branch)
            print(
                f"[{change}] Found existing remote bookmark (commit {old_remote_commit[:7]})"
            )

        # Create bookmark/branch and push
        try:
            # Create bookmark if it doesn't exist
            try:
                run(["jj", "bookmark", "create", branch, "-r", change], capture=True)
                print(f"[{change}] Created bookmark '{branch}'")
            except subprocess.CalledProcessError:
                # Bookmark might already exist, that's ok
                print(f"[{change}] Bookmark '{branch}' already exists")

            # Push the bookmark
            run(["jj", "git", "push", "--allow-new", "-b", branch])
            branches[change] = branch
            print(f"[{change}] Pushed bookmark '{branch}'")
        except subprocess.CalledProcessError as e:
            print(f"[{change}] Push failed: {e.stderr or str(e)}", file=sys.stderr)
            sys.exit(1)

        # Create or update PR
        try:
            if gh_pr_exists(branch, upstream_repo_url, fork_username):
                print(
                    f"[{change}] PR already exists for branch '{branch}', getting PR number..."
                )
                cmd = ["gh"]
                if upstream_repo_url:
                    cmd.extend(["-R", upstream_repo_url])
                cmd.extend(["pr", "view"])

                # Use fork_user:branch format if we're in fork workflow
                if fork_username and upstream_repo_url:
                    branch_spec = f"{fork_username}:{branch}"
                else:
                    branch_spec = branch

                cmd.extend([branch_spec, "--json", "number", "--jq", ".number"])
                cp = run(cmd)
                pr_num = int(cp.stdout.strip())
                print(f"[{change}] Found existing PR #{pr_num}")

                # Check if title needs updating
                existing_title = gh_pr_get_title(pr_num, upstream_repo_url)
                if existing_title != title:
                    gh_pr_set_title(pr_num, title, upstream_repo_url)
                    print(f"[{change}] Updated PR #{pr_num} title")

                # Add reviewers if specified
                if args.add_reviewer:
                    gh_pr_add_reviewers(pr_num, args.add_reviewer, upstream_repo_url)
                    print(f"[{change}] Added reviewers to PR #{pr_num}")

                # Post diff comment if we have the old remote commit
                if old_remote_commit:
                    code_diff = get_code_diff(old_remote_commit, change)
                    # Get full description for message diff
                    cp = run(
                        ["jj", "log", "-r", change, "-T", "description", "--no-graph"]
                    )
                    new_full_description = cp.stdout.strip()
                    message_diff = create_text_diff(
                        old_commit_message or "",
                        new_full_description,
                        "old/commit-message",
                        "new/commit-message",
                    )
                    comment_body = build_diff_comment(code_diff, message_diff)
                    gh_pr_comment(pr_num, comment_body, upstream_repo_url)
                    print(f"[{change}] Posted diff comment to PR #{pr_num}")

                pr_numbers[change] = pr_num
            else:
                # For single change, use commit body directly; for multiple changes we'll update later
                initial_body = body if len(changes) == 1 else ""
                pr_num = gh_pr_create(
                    branch,
                    args.base,
                    title,
                    initial_body,
                    args.add_reviewer,
                    upstream_repo_url,
                    fork_username,
                )
                print(f"[{change}] Created PR #{pr_num}")
                pr_numbers[change] = pr_num
        except subprocess.CalledProcessError as e:
            print(
                f"[{change}] PR creation/lookup failed: {e.stderr or str(e)}",
                file=sys.stderr,
            )
            sys.exit(1)

    # Update PR bodies based on whether it's single or stacked
    created_prs_in_order = [pr_numbers[c] for c in changes if pr_numbers.get(c, -1) > 0]

    if not args.dry_run:
        print("Updating PR descriptions…")

        # Get commit bodies for each change
        change_bodies = {}
        for change in changes:
            _, body = jj_description(change)
            change_bodies[change] = body

        for change in changes:
            pr_num = pr_numbers.get(change, -1)
            if pr_num <= 0:
                continue

            try:
                if len(created_prs_in_order) == 1:
                    # Single PR: use commit body directly
                    new_body = change_bodies[change] or ""
                else:
                    # Stacked PR: use special format
                    new_body = build_stacked_pr_body(
                        change,
                        pr_num,
                        created_prs_in_order,
                        change_bodies[change],
                        repo_name,
                    )

                # Check if body needs updating
                existing_body = gh_pr_get_body(pr_num, upstream_repo_url)
                if existing_body != new_body:
                    gh_pr_set_body(pr_num, new_body, upstream_repo_url)
                    print(f"[{change}] Updated PR #{pr_num} body")
                else:
                    print(f"[{change}] PR #{pr_num} body already up to date")

            except subprocess.CalledProcessError as e:
                print(
                    f"[{change}] Failed to update PR #{pr_num} body: {e.stderr or str(e)}",
                    file=sys.stderr,
                )
                sys.exit(1)

    # Summary
    print("\n=== Summary ===")
    for change in changes:
        branch = branches.get(change, "?")
        prn = pr_numbers.get(change, -1)
        if prn > 0:
            print(f"{change} -> branch '{branch}' -> PR #{prn}")
        else:
            print(f"{change} -> branch '{branch}' -> (no PR created in dry-run)")


if __name__ == "__main__":
    main()
